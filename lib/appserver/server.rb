require 'ostruct'
require 'etc'
require 'yaml'

module Appserver
  class Server < OpenStruct
    class AlreadyInitializedError < RuntimeError; end
    class NotInitialized < RuntimeError; end

    DEFAULTS = {
      :repo_dir => (Etc.getpwnam('git') rescue {})[:dir],
      :monit_conf => 'monitrc',
      :monit_reload => '/usr/sbin/monit reload',
      :nginx_conf => 'nginx.conf',
      :nginx_reload => '/usr/sbin/nginx -s reload',
      :thin => '/usr/local/bin/thin',
      :thin_opts => '-e production',
      :instances => 3,
      :pids_dir => 'tmp/pids',
      :sockets_dir => 'tmp/sockets',
      :server_log => 'log/server.log',
      :max_cpu_usage => nil,
      :max_memory_usage => nil,
      :usage_check_cycles => 5,
      :http_check_timeout => 30,
      :domain => `/bin/hostname -f`.chomp.gsub(/^[^.]+\./, ''),
      :access_log => 'log/access.log',
      :public_dir => 'public',
    }

    attr_reader :dir

    def config_file
      File.join(dir, 'appserver.yml')
    end

    def config_file_template
      File.expand_path('../appserver.yml', __FILE__)
    end

    def initialize (options = {})
      settings = DEFAULTS
      # Load configuration from given server directory, fall back to the current directory
      @dir = options.delete(:dir) || Dir.pwd
      if File.exist?(config_file)
        config_settings = YAML.load_file(config_file)
        settings.merge!((config_settings || {}).symbolize_keys!)
        @dir_initialized = true
      end
      # Let command line options override any settings
      settings.merge!(options)
      super(settings)
    end

    def dir_initialized?
      @dir_initialized
    end

    def initialize_dir
      raise AlreadyInitializedError if File.exist?(config_file)
      File.safe_replace(config_file) do |f|
        f.puts IO.read(config_file_template)
      end
    end

    def apps
      @app_names ||= Dir.glob(File.join(dir, '*')).select { |f| File.directory?(f) }.map { |f| File.basename(f) }
      @apps ||= @app_names.map do |name|
        settings = super && super[name]
        App.new(self, name, settings)
      end
      @apps
    end

    def write_configs
      raise NotInitialized unless dir_initialized?
      # Write Monit configuration file
      File.safe_replace(monit_conf) do |f|
        f.puts %Q(# Monit configuration automagically generated by the "appserver" gem using)
        f.puts %Q(# the server directory config #{config_file})
        f.puts %Q(# Include this file into your system's monitrc (using an include statement))
        f.puts %Q(# to use it. See http://github.com/zargony/appserver for details.)
        # Let Monit reload itself if this configuration changes
        f.puts %Q(check file monit_conf with path #{File.expand_path(monit_conf)})
        f.puts %Q(  if changed checksum then exec "#{monit_reload}")
        # Reload Nginx if its configuration changes
        f.puts %Q(check file nginx_conf with path #{File.expand_path(nginx_conf)})
        f.puts %Q(  if changed checksum then exec "#{nginx_reload}")
        # Add application-specific Monit configuration
        apps.each do |app|
          app.write_monit_config(f)
        end
      end
      # Write Nginx configuration file
      File.safe_replace(nginx_conf) do |f|
        f.puts %Q(# Nginx configuration automagically generated by the "appserver" gem using)
        f.puts %Q(# the server directory config #{config_file})
        f.puts %Q(# Include this file into your system's nginx.conf \(using an include statement)
        f.puts %Q(# inside a http statement\) to use it. See http://github.com/zargony/appserver)
        f.puts %Q(# for details.)
        # The default server always responds with 403 Forbidden
        f.puts %Q(server {)
        f.puts %Q(  listen 80 default;)
        f.puts %Q(  server_name _;)
        f.puts %Q(  deny all;)
        f.puts %Q(})
        # Add application-specific Nginx configuration
        apps.each do |app|
          app.write_nginx_config(f)
        end
      end
    end
  end
end
